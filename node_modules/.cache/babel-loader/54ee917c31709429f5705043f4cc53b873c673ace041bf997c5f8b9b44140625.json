{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$();\nimport { useEffect, useRef, useState } from 'react';\n\n/**\n * Custom hook for scroll-triggered reveal animations\n * @param {Object} options - IntersectionObserver options\n * @returns {Array} [ref, isVisible] - Ref to attach to element and visibility state\n */\nexport const useScrollReveal = (options = {}) => {\n  _s();\n  const ref = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n  useEffect(() => {\n    const threshold = options.threshold || 0.1;\n    const rootMargin = options.rootMargin || '0px 0px -50px 0px';\n    const observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) {\n        setIsVisible(true);\n        // Once visible, stop observing\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n      }\n    }, {\n      threshold,\n      rootMargin\n    });\n    const currentRef = ref.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return [ref, isVisible];\n};\n\n/**\n * Custom hook for parallax scroll effect\n * @param {number} speed - Parallax speed multiplier (default: 0.5)\n * @returns {Object} style object with transform\n */\n_s(useScrollReveal, \"Wk8baY7uc+CWSrD2kMBp+I8qtIg=\");\nexport const useParallax = (speed = 0.5) => {\n  _s2();\n  const [offset, setOffset] = useState(0);\n  useEffect(() => {\n    const handleScroll = () => {\n      setOffset(window.scrollY);\n    };\n    window.addEventListener('scroll', handleScroll, {\n      passive: true\n    });\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n  return {\n    transform: `translateY(${offset * speed}px)`\n  };\n};\n\n/**\n * Custom hook for staggered children animations\n * @param {number} childCount - Number of children to animate\n * @param {number} staggerDelay - Delay between each child (ms)\n * @returns {Array} Array of refs for each child\n */\n_s2(useParallax, \"WzXr9uhGfXxPyY3YDt08E2OJQzY=\");\nexport const useStaggeredReveal = (childCount, staggerDelay = 100) => {\n  _s3();\n  const containerRef = useRef(null);\n  const [visibleItems, setVisibleItems] = useState([]);\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      if (entry.isIntersecting) {\n        // Stagger the visibility of children\n        for (let i = 0; i < childCount; i++) {\n          setTimeout(() => {\n            setVisibleItems(prev => [...prev, i]);\n          }, i * staggerDelay);\n        }\n        if (containerRef.current) {\n          observer.unobserve(containerRef.current);\n        }\n      }\n    }, {\n      threshold: 0.1\n    });\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [childCount, staggerDelay]);\n  return [containerRef, visibleItems];\n};\n\n/**\n * Custom hook for mouse position tracking (for magnetic effects)\n * @returns {Object} { x, y } mouse coordinates relative to viewport\n */\n_s3(useStaggeredReveal, \"UurtyN1LqLf4TAiKW9SD7rYugQI=\");\nexport const useMousePosition = () => {\n  _s4();\n  const [position, setPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  useEffect(() => {\n    const handleMouseMove = e => {\n      setPosition({\n        x: e.clientX,\n        y: e.clientY\n      });\n    };\n    window.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n  return position;\n};\n\n/**\n * Custom hook for element hover state with position\n * @returns {Array} [ref, isHovered, hoverPosition]\n */\n_s4(useMousePosition, \"jv34aNIyPo+g3wMR9igNqlVW3h8=\");\nexport const useHoverPosition = () => {\n  _s5();\n  const ref = useRef(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [position, setPosition] = useState({\n    x: 0,\n    y: 0\n  });\n  useEffect(() => {\n    const element = ref.current;\n    if (!element) return;\n    const handleMouseEnter = () => setIsHovered(true);\n    const handleMouseLeave = () => setIsHovered(false);\n    const handleMouseMove = e => {\n      const rect = element.getBoundingClientRect();\n      setPosition({\n        x: e.clientX - rect.left - rect.width / 2,\n        y: e.clientY - rect.top - rect.height / 2\n      });\n    };\n    element.addEventListener('mouseenter', handleMouseEnter);\n    element.addEventListener('mouseleave', handleMouseLeave);\n    element.addEventListener('mousemove', handleMouseMove);\n    return () => {\n      element.removeEventListener('mouseenter', handleMouseEnter);\n      element.removeEventListener('mouseleave', handleMouseLeave);\n      element.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n  return [ref, isHovered, position];\n};\n_s5(useHoverPosition, \"Un4bVHQcySIKmtnQq8beCAZ3nGY=\");\nexport default useScrollReveal;","map":{"version":3,"names":["useEffect","useRef","useState","useScrollReveal","options","_s","ref","isVisible","setIsVisible","threshold","rootMargin","observer","IntersectionObserver","entry","isIntersecting","current","unobserve","currentRef","observe","useParallax","speed","_s2","offset","setOffset","handleScroll","window","scrollY","addEventListener","passive","removeEventListener","transform","useStaggeredReveal","childCount","staggerDelay","_s3","containerRef","visibleItems","setVisibleItems","i","setTimeout","prev","useMousePosition","_s4","position","setPosition","x","y","handleMouseMove","e","clientX","clientY","useHoverPosition","_s5","isHovered","setIsHovered","element","handleMouseEnter","handleMouseLeave","rect","getBoundingClientRect","left","width","top","height"],"sources":["/Users/dionisis/Desktop/labrosrepo/Vromiara-Gourmet-Streetfood/src/hooks/useAnimations.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\n/**\n * Custom hook for scroll-triggered reveal animations\n * @param {Object} options - IntersectionObserver options\n * @returns {Array} [ref, isVisible] - Ref to attach to element and visibility state\n */\nexport const useScrollReveal = (options = {}) => {\n  const ref = useRef(null);\n  const [isVisible, setIsVisible] = useState(false);\n\n  useEffect(() => {\n    const threshold = options.threshold || 0.1;\n    const rootMargin = options.rootMargin || '0px 0px -50px 0px';\n    \n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsVisible(true);\n          // Once visible, stop observing\n          if (ref.current) {\n            observer.unobserve(ref.current);\n          }\n        }\n      },\n      {\n        threshold,\n        rootMargin,\n      }\n    );\n\n    const currentRef = ref.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return [ref, isVisible];\n};\n\n/**\n * Custom hook for parallax scroll effect\n * @param {number} speed - Parallax speed multiplier (default: 0.5)\n * @returns {Object} style object with transform\n */\nexport const useParallax = (speed = 0.5) => {\n  const [offset, setOffset] = useState(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      setOffset(window.scrollY);\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, []);\n\n  return {\n    transform: `translateY(${offset * speed}px)`,\n  };\n};\n\n/**\n * Custom hook for staggered children animations\n * @param {number} childCount - Number of children to animate\n * @param {number} staggerDelay - Delay between each child (ms)\n * @returns {Array} Array of refs for each child\n */\nexport const useStaggeredReveal = (childCount, staggerDelay = 100) => {\n  const containerRef = useRef(null);\n  const [visibleItems, setVisibleItems] = useState([]);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          // Stagger the visibility of children\n          for (let i = 0; i < childCount; i++) {\n            setTimeout(() => {\n              setVisibleItems((prev) => [...prev, i]);\n            }, i * staggerDelay);\n          }\n          \n          if (containerRef.current) {\n            observer.unobserve(containerRef.current);\n          }\n        }\n      },\n      { threshold: 0.1 }\n    );\n\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [childCount, staggerDelay]);\n\n  return [containerRef, visibleItems];\n};\n\n/**\n * Custom hook for mouse position tracking (for magnetic effects)\n * @returns {Object} { x, y } mouse coordinates relative to viewport\n */\nexport const useMousePosition = () => {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (e) => {\n      setPosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener('mousemove', handleMouseMove, { passive: true });\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n\n  return position;\n};\n\n/**\n * Custom hook for element hover state with position\n * @returns {Array} [ref, isHovered, hoverPosition]\n */\nexport const useHoverPosition = () => {\n  const ref = useRef(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const element = ref.current;\n    if (!element) return;\n\n    const handleMouseEnter = () => setIsHovered(true);\n    const handleMouseLeave = () => setIsHovered(false);\n    const handleMouseMove = (e) => {\n      const rect = element.getBoundingClientRect();\n      setPosition({\n        x: e.clientX - rect.left - rect.width / 2,\n        y: e.clientY - rect.top - rect.height / 2,\n      });\n    };\n\n    element.addEventListener('mouseenter', handleMouseEnter);\n    element.addEventListener('mouseleave', handleMouseLeave);\n    element.addEventListener('mousemove', handleMouseMove);\n\n    return () => {\n      element.removeEventListener('mouseenter', handleMouseEnter);\n      element.removeEventListener('mouseleave', handleMouseLeave);\n      element.removeEventListener('mousemove', handleMouseMove);\n    };\n  }, []);\n\n  return [ref, isHovered, position];\n};\n\nexport default useScrollReveal;\n"],"mappings":";;;;;AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;;AAEnD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAGA,CAACC,OAAO,GAAG,CAAC,CAAC,KAAK;EAAAC,EAAA;EAC/C,MAAMC,GAAG,GAAGL,MAAM,CAAC,IAAI,CAAC;EACxB,MAAM,CAACM,SAAS,EAAEC,YAAY,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EAEjDF,SAAS,CAAC,MAAM;IACd,MAAMS,SAAS,GAAGL,OAAO,CAACK,SAAS,IAAI,GAAG;IAC1C,MAAMC,UAAU,GAAGN,OAAO,CAACM,UAAU,IAAI,mBAAmB;IAE5D,MAAMC,QAAQ,GAAG,IAAIC,oBAAoB,CACvC,CAAC,CAACC,KAAK,CAAC,KAAK;MACX,IAAIA,KAAK,CAACC,cAAc,EAAE;QACxBN,YAAY,CAAC,IAAI,CAAC;QAClB;QACA,IAAIF,GAAG,CAACS,OAAO,EAAE;UACfJ,QAAQ,CAACK,SAAS,CAACV,GAAG,CAACS,OAAO,CAAC;QACjC;MACF;IACF,CAAC,EACD;MACEN,SAAS;MACTC;IACF,CACF,CAAC;IAED,MAAMO,UAAU,GAAGX,GAAG,CAACS,OAAO;IAC9B,IAAIE,UAAU,EAAE;MACdN,QAAQ,CAACO,OAAO,CAACD,UAAU,CAAC;IAC9B;IAEA,OAAO,MAAM;MACX,IAAIA,UAAU,EAAE;QACdN,QAAQ,CAACK,SAAS,CAACC,UAAU,CAAC;MAChC;IACF,CAAC;IACD;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,CAACX,GAAG,EAAEC,SAAS,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AAJAF,EAAA,CAxCaF,eAAe;AA6C5B,OAAO,MAAMgB,WAAW,GAAGA,CAACC,KAAK,GAAG,GAAG,KAAK;EAAAC,GAAA;EAC1C,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGrB,QAAQ,CAAC,CAAC,CAAC;EAEvCF,SAAS,CAAC,MAAM;IACd,MAAMwB,YAAY,GAAGA,CAAA,KAAM;MACzBD,SAAS,CAACE,MAAM,CAACC,OAAO,CAAC;IAC3B,CAAC;IAEDD,MAAM,CAACE,gBAAgB,CAAC,QAAQ,EAAEH,YAAY,EAAE;MAAEI,OAAO,EAAE;IAAK,CAAC,CAAC;IAClE,OAAO,MAAMH,MAAM,CAACI,mBAAmB,CAAC,QAAQ,EAAEL,YAAY,CAAC;EACjE,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACLM,SAAS,EAAE,cAAcR,MAAM,GAAGF,KAAK;EACzC,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AALAC,GAAA,CAjBaF,WAAW;AAuBxB,OAAO,MAAMY,kBAAkB,GAAGA,CAACC,UAAU,EAAEC,YAAY,GAAG,GAAG,KAAK;EAAAC,GAAA;EACpE,MAAMC,YAAY,GAAGlC,MAAM,CAAC,IAAI,CAAC;EACjC,MAAM,CAACmC,YAAY,EAAEC,eAAe,CAAC,GAAGnC,QAAQ,CAAC,EAAE,CAAC;EAEpDF,SAAS,CAAC,MAAM;IACd,MAAMW,QAAQ,GAAG,IAAIC,oBAAoB,CACvC,CAAC,CAACC,KAAK,CAAC,KAAK;MACX,IAAIA,KAAK,CAACC,cAAc,EAAE;QACxB;QACA,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,EAAEM,CAAC,EAAE,EAAE;UACnCC,UAAU,CAAC,MAAM;YACfF,eAAe,CAAEG,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAEF,CAAC,CAAC,CAAC;UACzC,CAAC,EAAEA,CAAC,GAAGL,YAAY,CAAC;QACtB;QAEA,IAAIE,YAAY,CAACpB,OAAO,EAAE;UACxBJ,QAAQ,CAACK,SAAS,CAACmB,YAAY,CAACpB,OAAO,CAAC;QAC1C;MACF;IACF,CAAC,EACD;MAAEN,SAAS,EAAE;IAAI,CACnB,CAAC;IAED,MAAMQ,UAAU,GAAGkB,YAAY,CAACpB,OAAO;IACvC,IAAIE,UAAU,EAAE;MACdN,QAAQ,CAACO,OAAO,CAACD,UAAU,CAAC;IAC9B;IAEA,OAAO,MAAM;MACX,IAAIA,UAAU,EAAE;QACdN,QAAQ,CAACK,SAAS,CAACC,UAAU,CAAC;MAChC;IACF,CAAC;EACH,CAAC,EAAE,CAACe,UAAU,EAAEC,YAAY,CAAC,CAAC;EAE9B,OAAO,CAACE,YAAY,EAAEC,YAAY,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AAHAF,GAAA,CAtCaH,kBAAkB;AA0C/B,OAAO,MAAMU,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACpC,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAG1C,QAAQ,CAAC;IAAE2C,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAAC;EAExD9C,SAAS,CAAC,MAAM;IACd,MAAM+C,eAAe,GAAIC,CAAC,IAAK;MAC7BJ,WAAW,CAAC;QAAEC,CAAC,EAAEG,CAAC,CAACC,OAAO;QAAEH,CAAC,EAAEE,CAAC,CAACE;MAAQ,CAAC,CAAC;IAC7C,CAAC;IAEDzB,MAAM,CAACE,gBAAgB,CAAC,WAAW,EAAEoB,eAAe,EAAE;MAAEnB,OAAO,EAAE;IAAK,CAAC,CAAC;IACxE,OAAO,MAAMH,MAAM,CAACI,mBAAmB,CAAC,WAAW,EAAEkB,eAAe,CAAC;EACvE,CAAC,EAAE,EAAE,CAAC;EAEN,OAAOJ,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AAHAD,GAAA,CAfaD,gBAAgB;AAmB7B,OAAO,MAAMU,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACpC,MAAM9C,GAAG,GAAGL,MAAM,CAAC,IAAI,CAAC;EACxB,MAAM,CAACoD,SAAS,EAAEC,YAAY,CAAC,GAAGpD,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACyC,QAAQ,EAAEC,WAAW,CAAC,GAAG1C,QAAQ,CAAC;IAAE2C,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAAC;EAExD9C,SAAS,CAAC,MAAM;IACd,MAAMuD,OAAO,GAAGjD,GAAG,CAACS,OAAO;IAC3B,IAAI,CAACwC,OAAO,EAAE;IAEd,MAAMC,gBAAgB,GAAGA,CAAA,KAAMF,YAAY,CAAC,IAAI,CAAC;IACjD,MAAMG,gBAAgB,GAAGA,CAAA,KAAMH,YAAY,CAAC,KAAK,CAAC;IAClD,MAAMP,eAAe,GAAIC,CAAC,IAAK;MAC7B,MAAMU,IAAI,GAAGH,OAAO,CAACI,qBAAqB,CAAC,CAAC;MAC5Cf,WAAW,CAAC;QACVC,CAAC,EAAEG,CAAC,CAACC,OAAO,GAAGS,IAAI,CAACE,IAAI,GAAGF,IAAI,CAACG,KAAK,GAAG,CAAC;QACzCf,CAAC,EAAEE,CAAC,CAACE,OAAO,GAAGQ,IAAI,CAACI,GAAG,GAAGJ,IAAI,CAACK,MAAM,GAAG;MAC1C,CAAC,CAAC;IACJ,CAAC;IAEDR,OAAO,CAAC5B,gBAAgB,CAAC,YAAY,EAAE6B,gBAAgB,CAAC;IACxDD,OAAO,CAAC5B,gBAAgB,CAAC,YAAY,EAAE8B,gBAAgB,CAAC;IACxDF,OAAO,CAAC5B,gBAAgB,CAAC,WAAW,EAAEoB,eAAe,CAAC;IAEtD,OAAO,MAAM;MACXQ,OAAO,CAAC1B,mBAAmB,CAAC,YAAY,EAAE2B,gBAAgB,CAAC;MAC3DD,OAAO,CAAC1B,mBAAmB,CAAC,YAAY,EAAE4B,gBAAgB,CAAC;MAC3DF,OAAO,CAAC1B,mBAAmB,CAAC,WAAW,EAAEkB,eAAe,CAAC;IAC3D,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,CAACzC,GAAG,EAAE+C,SAAS,EAAEV,QAAQ,CAAC;AACnC,CAAC;AAACS,GAAA,CA/BWD,gBAAgB;AAiC7B,eAAehD,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}